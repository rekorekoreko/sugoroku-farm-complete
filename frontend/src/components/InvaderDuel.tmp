import { useEffect, useRef, useState } from 'react'

type Winner = 'player' | 'bot'

interface Props {
  onFinish: (winner: Winner) => void
  width?: number
  height?: number
}

// Minimal 1v1 invader-like duel on a canvas
export default function InvaderDuel({ onFinish, width = 420, height = 320 }: Props) {
  const canvasRef = useRef<HTMLCanvasElement | null>(null)
  const [phase, setPhase] = useState<'countdown' | 'playing'>('countdown')
  const phaseRef = useRef<'countdown' | 'playing'>('countdown')
  const overlayTextRef = useRef<string>('3')

  useEffect(() => {
    const canvas = canvasRef.current
    if (!canvas) return
    const ctx = canvas.getContext('2d')!

    let running = true
    const keys: Record<string, boolean> = {}

    const player = { x: width / 2, y: height - 24, w: 18, h: 8, speed: 3, lives: 3 }

    // Enemy grid
    const cols = 8
    const rows = 4
    const enemies: { x: number; y: number; w: number; h: number; alive: boolean }[] = []
    const gapX = 36
    const gapY = 22
    const startX = (width - (cols - 1) * gapX) / 2
    const startY = 40
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        enemies.push({ x: startX + c * gapX, y: startY + r * gapY, w: 18, h: 12, alive: true })
      }
    }

    // Enemy movement
    let dir = 1 // 1:right, -1:left
    let enemySpeed = 0.6
    let stepDown = false

    // Player bullets (allow up to 3 on screen)
    const pBullets: { x: number; y: number; w: number; h: number; v: number }[] = []

    // Enemy bullets
    const eBullets: { x: number; y: number; w: number; h: number; v: number }[] = []
    let lastEnemyShot = 0
    let enemyShotInterval = 900

    const onKeyDown = (e: KeyboardEvent) => {
      keys[e.key] = true
      if (phaseRef.current !== 'playing') return
      if (e.key === ' ' || e.code === 'Space') {
        if (pBullets.length < 3) pBullets.push({ x: player.x, y: player.y - 8, w: 2, h: 8, v: -4 })
      }
    }
    const onKeyUp = (e: KeyboardEvent) => {
      keys[e.key] = false
    }
    window.addEventListener('keydown', onKeyDown)
    window.addEventListener('keyup', onKeyUp)

    function clamp(v: number, min: number, max: number) { return Math.max(min, Math.min(max, v)) }
    function rectHit(ax: number, ay: number, aw: number, ah: number, bx: number, by: number, bw: number, bh: number) {
      return Math.abs(ax - bx) < (aw/2 + bw/2) && Math.abs(ay - by) < (ah/2 + bh/2)
    }

    function update(now: number) {
      if (phaseRef.current !== 'playing') return
      // player move
      if (keys['ArrowLeft'] || keys['a'] || keys['A']) player.x -= player.speed
      if (keys['ArrowRight'] || keys['d'] || keys['D']) player.x += player.speed
      player.x = clamp(player.x, player.w/2 + 6, width - player.w/2 - 6)

      // enemy group bounds
      let minX = Infinity, maxX = -Infinity
      for (const e of enemies) if (e.alive) { minX = Math.min(minX, e.x); maxX = Math.max(maxX, e.x) }
      if (minX === Infinity) { // all dead -> win
        running = false
        onFinish('player')
        return
      }
      const leftEdge = minX - 12
      const rightEdge = maxX + 12
      if (rightEdge + enemySpeed * dir > width - 8 || leftEdge + enemySpeed * dir < 8) {
        dir *= -1
        stepDown = true
        enemySpeed = Math.min(2.5, enemySpeed + 0.05)
      }
      for (const e of enemies) {
        if (!e.alive) continue
        e.x += enemySpeed * dir
        if (stepDown) e.y += 8
        if (e.y + e.h/2 >= player.y - player.h/2) {
          running = false
          onFinish('bot')
          return
        }
      }
      stepDown = false

      // enemy shooting
      if (now - lastEnemyShot > enemyShotInterval) {
        const alive = enemies.filter(e => e.alive)
        if (alive.length > 0) {
          const shooter = alive[Math.floor(Math.random() * alive.length)]
          eBullets.push({ x: shooter.x, y: shooter.y + shooter.h/2 + 2, w: 2, h: 8, v: 2.8 })
          lastEnemyShot = now
          enemyShotInterval = 700 + Math.random() * 700
        }
      }

      // move bullets
      for (const b of pBullets) b.y += b.v
      for (const b of eBullets) b.y += b.v
      // cull offscreen
      for (let i = pBullets.length - 1; i >= 0; i--) if (pBullets[i].y < -12) pBullets.splice(i,1)
      for (let i = eBullets.length - 1; i >= 0; i--) if (eBullets[i].y > height + 12) eBullets.splice(i,1)

      // collisions: player bullets vs enemies
      for (const b of pBullets) {
        for (const e of enemies) {
          if (!e.alive) continue
          if (rectHit(b.x, b.y, b.w, b.h, e.x, e.y, e.w, e.h)) {
            e.alive = false
            b.y = -9999
            break
          }
        }
      }
      // collisions: enemy bullets vs player
      for (const b of eBullets) {
        if (rectHit(b.x, b.y, b.w, b.h, player.x, player.y, player.w, player.h)) {
          b.y = height + 9999
          player.lives -= 1
          if (player.lives <= 0) {
            running = false
            onFinish('bot')
            return
          }
        }
      }
    }

    function legacyDraw() {
      ctx.fillStyle = '#0f172a' // slate-900
      ctx.fillRect(0, 0, width, height)

      // center line
      ctx.strokeStyle = 'rgba(255,255,255,0.1)'
      ctx.beginPath()
      ctx.moveTo(0, height/2)
      ctx.lineTo(width, height/2)
      ctx.stroke()

      // player
      ctx.fillStyle = '#22c55e' // green-500
      ctx.fillRect(player.x - player.w/2, player.y - player.h/2, player.w, player.h)

      // bot
      ctx.fillStyle = '#ef4444' // red-500
      ctx.fillRect(bot.x - bot.w/2, bot.y - bot.h/2, bot.w, bot.h)

      // bullets
      if (pBullet.active) {
        ctx.fillStyle = '#a3e635' // lime-400
        ctx.fillRect(pBullet.x - pBullet.w/2, pBullet.y - pBullet.h/2, pBullet.w, pBullet.h)
      }
      if (bBullet.active) {
        ctx.fillStyle = '#f97316' // orange-500
        ctx.fillRect(bBullet.x - bBullet.w/2, bBullet.y - bBullet.h/2, bBullet.w, bBullet.h)
      }

      // HUD
      ctx.fillStyle = 'rgba(255,255,255,0.85)'
      ctx.font = '12px monospace'
      ctx.fillText('← → / A D: 移動, Space: 射撃', 10, height - 8)

      // Countdown overlay
      if (phaseRef.current !== 'playing') {
        ctx.fillStyle = 'rgba(0,0,0,0.35)'
        ctx.fillRect(0, 0, width, height)
        ctx.fillStyle = '#ffffff'
        ctx.font = 'bold 48px monospace'
        const text = overlayTextRef.current
        const metrics = ctx.measureText(text)
        const tw = metrics.width
        ctx.fillText(text, (width - tw) / 2, height / 2)
      }
    }

    // New draw for Space-Invaders gameplay
    function draw() {
      const ctx = canvasRef.current!.getContext('2d')!
      ctx.fillStyle = '#0b1020'
      ctx.fillRect(0, 0, width, height)
      // player
      ctx.fillStyle = '#22c55e'
      ctx.fillRect(player.x - player.w/2, player.y - player.h/2, player.w, player.h)
      // enemies
      for (const e of enemies) {
        if (!e.alive) continue
        ctx.fillStyle = '#60a5fa'
        ctx.fillRect(e.x - e.w/2, e.y - e.h/2, e.w, e.h)
      }
      // bullets
      ctx.fillStyle = '#a3e635'
      for (const b of pBullets) ctx.fillRect(b.x - b.w/2, b.y - b.h/2, b.w, b.h)
      ctx.fillStyle = '#f97316'
      for (const b of eBullets) ctx.fillRect(b.x - b.w/2, b.y - b.h/2, b.w, b.h)
      // HUD
      ctx.fillStyle = 'rgba(255,255,255,0.85)'
      ctx.font = '12px monospace'
      ctx.fillText('← → / A D: move, Space: fire', 10, height - 8)
      ctx.fillText(`Lives: ${player.lives}`, width - 80, height - 8)
      // Countdown overlay
      if (phaseRef.current !== 'playing') {
        ctx.fillStyle = 'rgba(0,0,0,0.4)'
        ctx.fillRect(0, 0, width, height)
        ctx.fillStyle = '#ffffff'
        ctx.font = 'bold 44px monospace'
        const text = overlayTextRef.current
        const metrics = ctx.measureText(text)
        ctx.fillText(text, (width - metrics.width) / 2, height / 2)
      }
    }

    let last = performance.now()
    function loop(now: number) {
      last = now
      if (!running) return
      update(now)
      draw()
      requestAnimationFrame(loop)
    }
    requestAnimationFrame(loop)

    return () => {
      running = false
      window.removeEventListener('keydown', onKeyDown)
      window.removeEventListener('keyup', onKeyUp)
    }
  }, [onFinish, width, height])

  // Pre-start countdown: 3 -> 2 -> 1 -> Start! -> playing
  useEffect(() => {
    phaseRef.current = 'countdown'
    setPhase('countdown')
    overlayTextRef.current = '3'
    const t1 = setTimeout(() => { overlayTextRef.current = '2' }, 700)
    const t2 = setTimeout(() => { overlayTextRef.current = '1' }, 1400)
    const t3 = setTimeout(() => { overlayTextRef.current = 'Start!' }, 2100)
    const t4 = setTimeout(() => {
      phaseRef.current = 'playing'
      setPhase('playing')
      overlayTextRef.current = ''
    }, 2800)
    return () => { clearTimeout(t1); clearTimeout(t2); clearTimeout(t3); clearTimeout(t4) }
  }, [])

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/70">
      <div className="bg-white rounded-lg shadow-xl p-3 w-[400px] max-w-[92vw]">
        <div className="text-center font-semibold mb-2">ミニゲーム：インベーダー決闘</div>
        <div className="flex items-center justify-center">
          <canvas ref={canvasRef} width={width} height={height} className="pixelated" />
        </div>
        <div className="text-center text-xs text-gray-600 mt-2">先に相手へヒットした方の勝ち</div>
      </div>
    </div>
  )
}
